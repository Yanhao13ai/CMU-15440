# CMU-15440
http://www.composablesystems.org/15-440/fa2024/<br />
### Introduction
when does a decentralized system become distributed? in general, adding k>0 links bt two nodes in a decentralized system, alternative approach exists when 2 views on realizing distributed systems: integrative view -connecting existing networked computer systems into a larger system, expansive view -an existing networked computer systems is extended with additional computers, hence, 2 definitions: a decentralized system is a networked computer system in which processes and resources are necessarily spread across multiple computers, a distributed system is a networked computer system in which processes and resources are sufficiently spread across multiple computers;<br />
****
some common misconceptions including: centralized solutions do not scale -make distinction bt logically and physically centralized, the root of dns including: logically centralized, physically(massively) distributed, decentralized across several organizations; centralized solutions have a single point of failure -generally not true such as the root of dns, a single point of failure is often easier to manage, and easier to make more robust; note: there are many, poorly founded, misconceptions regarding scalability, fault tolerance, security, etc., we need to develop skills by which distributed systems can be readily understood so as to judge such misconceptions;<br />
distributed systems are complex taking perspectives of: architecture -common organizations, process -what kind of processes and their relationships, communication -facilities for exchanging data, coordination -application-independent algorithms, naming -how do you identify resources?, consistency and replication -performance requires of data which need to be the same, fault tolerance -keep running in the presence of partial failures, security -ensure authorized access to resources;<br />
what do we want to achieve? overall design goals including: support sharing of resources, distribution transparency, openness, scalability;<br />
sharing resources: canonnical examples including: cloud-based shared storage and files, p2p assisted multimedia streaming, shared mail services such as outsourced mail systems, shared web hosting such as content distribution networks; observation -“the network is the computer,” quote from John Gage, then at Sun Microsystems;<br />
distribution transparency: transparency -the phenomenon by which a distributed system attempts to hide the fact that its processes and resources are physically distributed across multiple computers, possibly separated by large distances; observation -distribution transparency is handled through many different techniques in a layer bt applications and os, i.e., a middleware layer; types including: access -hide differences in data representation and how an object is accessed, location -hide where an object is located, relocation -hide that an object may be moved to another location while in use, migration -hide that an object may move to another location, replication -hide that an object is replicated, concurrency -hide that an object may be shared by several independent users, failure -hide the failure and recovery of an object;<br />
degree of transparency including: (i) aiming at full distribution transparency may be too much: there are communication latencies that cannot be hidden; completely hiding failures of networks and nodes is(theoretically and practically) impossible, i.e., you cannot distinguish a slow computer from a failing one, and you cannot be sure that a server actually performed an op before a crash; full transparency will cost perf, exposing distribution of the system, i.e., keeping replicas exactly up-to-date with the master takes time, and immediately flushing write op to disk for fault tolerance;<br />
(ii) exposing distribution may be too good: making use of location-based services -finding your nearby friends, when dealing with users in different time zones, when it makes it easier for a user to understand what's going on -when for example, a server does not respond for a long time, report it as failing; conclusion -distribution transparency is a nice goal, but achieving it is a different story, and it should often not even be aimed at;<br />
openness of distributed systems: open -a system that offers components that can easily be used by, or integrated into other systems, an open distributed system itself will often consist of components that originate from elsewhere; what are we talking about? be able to interact with services from other open systems, irrespective of the underlying environment -systems should be conform to well-defined interfaces, systems should be easily interoperate, systems should support portability of applications, systems should be easily extensible;<br />
policies vs. mechanisms: policies including: what level of consistency do we require for client-based data? which op do we allow downloaded code to perform? which qos requirements do we adjust in the face of varying bandwidth? what level of secrecy do we require for communication? mechanisms including: allow (dynamic) setting of caching policies, support different levels of trust for mobile code, provide adjustable qos params per data stream, offer different encryption algorithms;<br />
on strict separation: observation -the stricter the separation bt policy and mechanism, the more we need to ensure proper mechanisms, potentially leading to many config params and complex mgt; finding a balance -hard-coding policies often simplifies mgt, and reduces complexity at the price of less flexibility, there is no obvious solution;<br />
一些常见的误解包括：集中式解决方案不具备扩展性 - 区分逻辑集中式和物理集中式，DNS 的根源包括：逻辑上集中式，物理上（大规模）分布式，跨多个组织分散式；集中式解决方案具有单点故障 - 一般情况并非如此，例如 DNS 的根源，单点故障通常更易于管理，并且更容易变得更加稳健；注意：关于可扩展性、容错性、安全性等，存在许多毫无根据的误解，我们需要培养能够轻松理解分布式系统的技能，以便判断这些误解；<br />
分布式系统很复杂，从以下角度来看：架构-通用组织、流程-什么样的流程及其关系、通信-交换数据的设施、协调-独立于应用程序的算法、命名-如何识别资源？、一致性和复制-需要相同的数据的性能要求、容错性-在部分故障的情况下保持运行、安全性-确保对资源的授权访问；<br />
我们想要实现什么？总体设计目标包括：支持资源共享、分发透明度、开放性、可扩展性；<br />
共享资源：典型示例包括：基于云的共享存储和文件、p2p辅助多媒体流、共享邮件服务（如外包邮件系统）、共享网络托管（如内容分发网络）；观察 -“网络就是计算机”，引用当时在 Sun Microsystems 工作的 John Gage 的话；<br />
分布透明度：透明度 - 分布式系统试图隐藏其进程和资源在物理上分布在多台计算机上的事实的现象，这些计算机可能相隔很远；观察 - 分布透明度通过应用程序和操作系统层（即中间件层）中的许多不同技术来处理；类型包括：访问 - 隐藏数据表示和对象访问方式的差异，位置 - 隐藏对象所在的位置，重定位 - 隐藏对象在使用时可能被移动到另一个位置，迁移 - 隐藏对象可能移动到另一个位置，复制 - 隐藏对象被复制，并发 - 隐藏对象可能由多个独立用户共享，故障 - 隐藏对象的故障和恢复；<br />
透明度程度包括：(i) 旨在实现完全分布透明度可能太多：存在无法隐藏的通信延迟；完全隐藏网络和节点故障（在理论上和实践上）是不可能的，即你无法区分运行缓慢的计算机和发生故障的计算机，也无法确定服务器在崩溃前是否真正执行了操作；完全透明会降低性能，暴露系统的分布，即保持副本与主服务器完全同步需要时间，并且为了容错，会立即将写入操作刷新到磁盘；<br />
(ii) 暴露分布可能太好了：利用基于位置的服务 - 找到你附近的朋友，当与不同时区的用户打交道时，当它使用户更容易了解发生了什么时 - 例如，当服务器长时间没有响应时，报告它为故障；结论 - 分布透明性是一个不错的目标，但实现它是另一回事，而且通常甚至不应该以此为目标；<br />
分布式系统的开放性：开放 - 提供可轻松使用或集成到其他系统的组件的系统，开放的分布式系统本身通常由来自其他地方的组件组成；我们在说什么？能够与其他开放系统的服务进行交互，而不管底层环境如何 - 系统应符合定义良好的接口，系统应易于互操作，系统应支持应用程序的可移植性，系统应易于扩展；<br />
政策与机制：政策包括：我们需要客户端数据的什么级别的一致性？我们允许下载的代码执行哪些操作？面对变化的带宽，我们要调整哪些 QoS 要求？我们需要什么级别的通信保密性？机制包括：允许（动态）设置缓存策略、支持不同级别的移动代码信任、为每个数据流提供可调整的 QoS 参数、提供不同的加密算法；<br />
关于严格分离：观察 - BT 策略和机制分离越严格，我们越需要确保适当的机制，这可能会导致许多配置参数和复杂的管理；找到平衡点 - 硬编码策略通常会简化管理，并以灵活性较低为代价降低复杂性，没有明显的解决方案；<br />
****
dependability: a component provides services to clients; to provide services, the component may require the services from other components -a component may depend on some other component; specifically, a component *C* depends on *C** if the correctness of *C*'s behavior depends on the correctness of *C**'s behavior, here, components are processes or channels; requirements related to dependability including: availability -readiness for usage, reliability -continuity of service delivery, safety -very low prob of catastrophes, maintainability -how easy can a failed system be repaired;<br />
reliability vs. availability: reliability *R(t)* of component *C* -conditional prob that *C* has been functioning correctly during *[0,t)* given *C* was functioning correctly at time *T=0*; traditional metrics including: MTTF, MTTR, MTBF=MTTF+MTBF, here mean time to failure -the average time until a component fails, mean time to repaire -the average time needed to repair a component, mean time bt failures; terminology: failure -a component is not living up to its specifications such as crashed prog, error -part of a component that can lead to a failure such as prog bug, fault -cause of an error such as sloppy programmer, (handling faults including:) fault prevention -prevent the occurance of a fault such as do not hire sloppy programmers, fault tolerance -build a component and make it mask the occurance of a fault such as building each component by 2 independent programmers, fault removal -reduce the presence, number, or seriousness of a fault, such as getting rid of sloppy programmers, fault forecasting -estimate current presence, future incidence, and consequences of faults, such as estimating how a recruiter is doing when it comes to hiring sloppy programmers;<br />
on security: observation -a distributed system that is not secure, is not dependable; what we need? confidentiality -info is disclosed only to authorized parties, integrity -ensure that alterations to assets of a system can be made only in an authorized way; authorization -verifying the correctness of a claimed identity, authentication -does an identified entity has proper access rights?, trust -one entity can be assured that another will perform particular actions according to a specific expectation;<br />
security mechanisms: (i) keeping it simple: it is all about encrypting and decrypting data using security keys;<br />
(ii) notation: *K(data)* denotes that we use key K to encrypt and decrypt data;<br />
(iii) symmetric cryptosystem: with encryption key *E_K(data)* and decryption key *D_K(data)*, if *data=D_K(E_K(data))* then *D_K=E_K*, note: encryption and decryption key are the same and should be kept secret; asymmetric cryptosystem: distinguish a public key *PK(data)* and a private secret key *SK(data)* -encrypt msg from Alice to Bob as *data=SK_bob(data)*, sign msg for Bob by Alice as *[data,data=PK_alice(SK_alice(data))]=[data,SK_alice(data)]*;<br />
(iv) secure hashing: in practice, we use secure hash functions -*H(data)* returns a fixed-length string, hence, any change from *data* to *data** will lead to a completely different string *H(data*)*, given a hash value, it is computationally impossible to find a data with *h=H(data)*;<br />
(v) practical digital signatures: sign msg for Bob by Alice as *[data,H(data)=PK_alice(sgn)]=[data,H,sgn=SK_alice(H(data))]*;<br />
scale in distributed systems: at least 3 components including: #users or processes -size scalability, max distance bt nodes -geographical scalability, #administrative domains -administrative scalability; observation -most systems account only for size scalability, often a solution -multiple powerful servers operating independently in parallel, today, the challenge still lies in geographical and administrative scalability;



